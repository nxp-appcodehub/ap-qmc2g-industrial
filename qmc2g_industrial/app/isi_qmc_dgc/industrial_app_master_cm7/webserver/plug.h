/*
 * Copyright 2023 NXPÂ 
 *
 * NXP Confidential and Proprietary. This software is owned or controlled by NXP and may only be used strictly
 * in accordance with the applicable license terms. By expressly accepting such terms or by downloading,
 * installing, activating and/or otherwise using the software, you are agreeing that you have read,
 * and that you agree to comply with and are bound by, such license terms. If you do not agree to be bound by
 * the applicable license terms, then you may not retain, install, activate or otherwise use the software.
 */

#ifndef CIT_HTTPD_PLUG_H
#define CIT_HTTPD_PLUG_H
#include <lwip/opt.h>
#include <lwip/ip_addr.h>
#include <lwip/altcp.h>

#include <cmsis_compiler.h>
#include <stdint.h>
#include <stdio.h>

#include "cit_httpd_opt.h"
#include "constants.h"
#include "plug_macros.h"

/**
 * @brief request handling plugin system
 * for the cit_httpd server
 *
 * implements a matching rules system for dispatching requests
 *
 * plugins are declared in headers with EXTERN_PLUG_EXTENSION(plug_example)
 * plugins are implemented in a file  with PLUG_EXTENSION(plug_example)
 * to get a global symbol to use in the rules, g_plug_example_extension
 *
 * then a set of callbacks can be defined implement the plugin
 * <returntype> plug_example_<callback>(<parameters)>
 *
 * all collbacks are optional.
 * implement the ones needed for he operation of the plugin
 *
 *  Table of plug callbacks
 *
 *  - initializer     called once upon registering the rule with the webserver, global setup
 *
 * all other callbacks are only called when the pattern matched
 *
 *  - on_match        called when a rule mattern matches changing the request influences
 *                    further rule processing, you can e.g. change the path of a request.
 *                    return 0 to continue matching, -1 to not consider the rule any more,
 *                    negative http status codes to force calling the error handler
 *                    positive status code to terminate rule processing early and handle the
 *                    request in this plug.
 *
 *  - on_cleanup      called for all plugs whose pattern matched, and whose on_match was called.
 *                    this is not called for plugs where on_match returned -1!
 *
 *  - on_body_data    called for body data of a request, might be called multiple times
 *                    if the body was not complete within one packet.
 *                    body data is kept around for the next call, if you do not
 *                    fclose(body), if content_length > len the call will be repeated once more data
 *                    is buffered.
 *
 *  - on_reply        called once the request is complete, when all handlers above have been processed
 *                    returning a positive status code states that this plug will create the final response.
 *                    returning a negative status code will call the last matched error handler plug
 *                    in both cases no further rules will be processed.
 *                    returning 0 will continue to the next rule, this plug will be called for send_headers.
 *                    this MUST set the content_length of any response generated by send_body.
 *
 * - check_resource   this is like 'on_reply', but called when an Expect: 100-Continue or an
 *		      If-Match: If-None-Match/ etag query is performed
 *		      it should initialize the etag related fields like on_reply would do
 *
 * - write_headers    will be called for all matched plugs, up to the one that replies with a body,
 *		      to generate header fields
 * - write_body_data  will be called for the one plug that sends the reply.
 *		      if on_reply did set a content length it's expected to emit as many bytes as specified
 *		      and will called multiple times to do so.
 *		      if content_length was set to zero or error_handing is done,
 *		      it's called prior writing headers, it is invoked one time and it's output is used
 *		      to set the content_length in the response.
 *
 *
 */

typedef struct plug_header plug_header_t;

#define PLUG_CALLBACK_LIST(entry, _)                                                                                 \
    _(entry, initializer, void, const plug_rule_t *rule)                                                             \
    _(entry, on_match, http_status_t, plug_state_p state, const plug_rule_t *rule, plug_request_t *request)          \
    _(entry, on_cleanup, void, plug_state_p state, const plug_rule_t *rule, const plug_request_t *request,           \
      const plug_response_t *response, http_status_t status_code)                                                    \
    _(entry, on_body_data, http_status_t, plug_state_p state, const plug_rule_t *rule, plug_request_t *request,      \
      plug_response_t *response, FILE *body, u16_t len)                                                              \
    _(entry, on_reply, http_status_t, plug_state_p state, const plug_rule_t *rule, plug_request_t *request,          \
      plug_response_t *response, http_status_t status_code)                                                          \
    _(entry, on_check_resource, http_status_t, plug_state_p state, const plug_rule_t *rule, plug_request_t *request, \
      plug_response_t *response, http_status_t status_code)                                                          \
    _(entry, write_headers, void, plug_state_p state, const plug_rule_t *rule, plug_request_t *request,              \
      plug_response_t *response, http_status_t status_code, FILE *headers)                                           \
    _(entry, write_body_data, void, plug_state_p state, const plug_rule_t *rule, plug_request_t *request,            \
      const plug_response_t *response, http_status_t status_code, FILE *body, u16_t sndbuf)                          \
    /* */

/**
 * @brief static rule definition macro
 *
 * rules are used to dispatch requests.
 *
 * the first argument is a pattern to match a request against
 * the second argument specifies http methods this rule applies to
 *
 *  HTTP_ANY      any method
 *  HTTP_GET
 *  HTTP_HEAD
 *  HTTP_POST
 *  HTTP_PUT
 *  HTTP_DELETE
 *  HTTP_CONNECT
 *  HTTP_OPTIONS
 *  HTTP_TRACE
 *  HTTP_PATCH
 *  HTTP_ERROR_HANDLER register as an error handler
 *  HTTP_ANY_RECV (HTTP_POST | HTTP_PUT | HTTP_PATCH)
 *
 * the consist of a match pattern, the plug callback to use as well as flags and options that ar plug specific.
 *
 * two macros can be used to create a rule, a rule is only applied if any of the methods matches
 *
 * PLUG_PATTERN("pattern",HTTP_ANY)
 *
 * to only create a match pattern as a precondition to further matches
 *
 * PLUG_RULE   ("pattern",HTTP_GET,plug_name,flags_int,data)
 *
 * to dispatch a request to a plug, the plugin to handle or try to handle the request
 *
 * a PATTERN of NULL will not match on processing, this can be used to register custom error responders.
 *
 * static const plug_rule_t[] = {
 *     // path starting with '/' -> plug_zip
 *     PLUG_RULE("/",HTTP_GET,plug_zip,length_of_zip_data,pointer_to_zip_data),
 *     // permanently redirect index.htm or index.html to '/'
 *     PLUG_RULE("/index.html?$",HTTP_GET,plug_redirect,301,"/"),
 * }
 *
 * pattern syntax: <prefix> <pattern>*
 *
 * the <prefix> consists of three groups of characters influencing pattern processing
 *
 * logic prefixes
 * "&..." only match if the previous rule did match      (optional)
 * "|..." only match if the previous rule did not match  (optional)
 *
 * "!..." negate matching result  (optional logic prefixes must be in front of it, if any)
 * if the pattern matches, returns false, otherwise true and the match is set to the start of the string source
 *
 *  [=:?#@] one of those options to select the match string source (optional, all other characters match on the path of
 * the request)
 *  "=" match on full URI
 *  ":" match the string of the local port used
 *  "?" match on the query parameters, (you probably want "&?..." to match after a rule matching a path)
 *  "#" match on the fragment part, ("&#..." after a path match?)
 *  "@" match on the name of the interface of the request "@en0" only en0 "!@en[03]" not en0 or en3
 *  "." start matching at the end of the last successful match  (the server path always starts with)
 *  <anything else> match on path (the server path always starts with /)
 *
 * "/api"          "/api"        (path match)
 * "./users"       "/api/users"  (relative match, assuming /api did match)
 * "&:80"          "/api/users"  (if on port 80)
 * ":443"          <any>         (if on port 443)
 * "&/login"       "/login"      (if on port 443)
 * "|/login"       "/login"      (if not "/login" or port 443)
 * "!/api"         <any>         (if not starting with /api)
 *
 * pattern matching is based on 'lua' string pattern matching, with group capture support removed
 * and implicit start of matching at the beginning of the string.
 *
 * prefix  = [&|]? [!]? [=:?#@]?
 * pattern =  ( <literal> | <class> ) <repetition>
 * repetitions = [*+-?] | %bxy  | | %f\[(<literal>|<class>)*] |
 * class= . | %[aAcCdDlLpPsSuUwWxXzZ] | \[<set>\]
 * literals = letters without classes without '[]$()%' with escape '%' '%%'
 *
 * .  matches everything
 * %a Equivalent to [a-zA-Z].
 * %d Equivalent to [0-9]
 * %l Equivalent to [a-z]
 * %u Equivalent to [A-Z]
 * %w Equivalent to [a-zA-Z0-9]
 * %x hexadecimal digit %s whitespace %p punctuation %z nullbyte
 *
 * uppercase classes are negating the lowercase ones
 * %A everything not in %a etc
 *
 * %bxy balanced matches %b() matches balanced pairs of braces ... %b<> %b[]
 * %f[<set>] frontier match, match when when the previous character doesn't match it
 * %f[%w] matches word boundaries
 * %f[.] matches word boundaries to a dot character
 *
 * basic pattern matching as implemented it the lua scripting language,
 * without match groups and with implicit start at the beginning
 * (all rules implicitly start with ^ in a regex or lua pattern)
 *
 * @param PATTERN  match pattern string
 * @param METHODS  flag bits of  `enum http_method` values (HTTP_GET|HTTP_DELETE...)
 * @param PLUG     name of the plug extension
 * @param FLAGS
 * @param
 *
 * @return assembled plug_rule_t struct literal.
 */
#define PLUG_RULE(PATTERN, METHODS, PLUG, FLAGS, OPTIONS) (_PLUG_RULE(METHODS, PATTERN, PLUG, FLAGS, OPTIONS))

/**
 * @brief static rule for matching a pattern
 * @param METHODS  flag bits of  `enum http_method` values (HTTP_GET|HTTP_DELETE...)
 * @param PATTERN  match pattern string
 *
 * used to only create a pattern to match.
 * chain using prefixes with a PLUG_RULE
 *
 * @return assembled plug_rule_t struct literal.
 */
#define PLUG_PATTERN(PATTERN, METHODS) (_PLUG_RULE(METHODS, PATTERN, plug_none, 0, NULL))

/**
 * @brief macro to create plugin header
 */
#define PLUG_EXTENSION_PROTOTYPE(name) extern _PLUG_EXTENSION_PROTOTYPE(name)

#if __GNUC__
#define GCC_PRAGMA(x) _Pragma(#x)
#else
#define GCC_PRAGMA(x)
#endif

/**
 * @brief macro to start an plugin implementation
 *
 * creates a static struct instance 'regname'
 *
 * regname.fhash the fieldhash
 * regname.value[value_size] is the header value (char array)
 * regname.field[field_size] is the text representation of the field name
 * regname.is_set is true if the header was present in the request
 *
 */
#define PLUG_EXTENSION_REGISTER_HEADER(regname, fieldhash, value_size, field_size) \
    _PLUG_EXTENSION_REGISTER_HEADER(regname, fieldhash, value_size, field_size)

/**
 * @brief macro to start an plugin implementation
 *        arguments after the name refer to registered headers.
 */
#define PLUG_EXTENSION(name, ...)                           \
    GCC_PRAGMA(GCC diagnostic error "-Wmissing-prototypes") \
    _PLUG_EXTENSION(name, __VA_ARGS__)

/**
 * @typedef integer type used to denote djb2_hashes
 */
typedef u32_t hash_t;

/**
 * @typedef plug extension type
 */
typedef struct plug_extension plug_extension_t;

/**
 * @struct definition of a rule
 */
typedef struct plug_rule
{
    const char *pattern;          /*!< match pattern string */
    int methods;                  /*!< HTTP_GET | HTTP_HEAD ... */
    const plug_extension_t *plug; /*!< link to the plug extension that handles this rule */
    int flags;                    /*!< flags for the plug extension to use */
    void *options;                /*!< data for the plug extension to use */
} plug_rule_t;

/**
 * @brief definition of the state per rule of a plug extension, abstract type, with a known size
 * plugs use custom structs that must fit into this definition.
 */
typedef struct abstract_plug_state
{
    char buffer[PLUG_STATE_SIZE];
} abstract_plug_state_t;

/**
 * @brief the state of a rule match.
 */
typedef struct plug_rule_match
{
    const plug_rule_t *rule;
    const char *match_end;
    abstract_plug_state_t state;
    http_status_t status_code; /* status_code */
} plug_rule_match_t;

/**
 * @brief type for header storage
 * a pointer to a NULL terminated list of headers a
 * plug wants to store is returned from the initializer
 *
 * fhash must be set to the field_hash of the requested header
 * flag is a pointer to an flag variable for the presence
 * value_ptr/value_size should point to the plugs buffer for the value if it should be stored
 * field_ptr/field_size should point to the plugs buffer for the field if it should be stored
 */
typedef struct plug_header
{
    hash_t fhash;
    bool *is_set;
    char *value_ptr;
    size_t value_size;
    char *field_ptr;
    size_t field_size;
} plug_header_t;

/**
 * @brief response data struct
 */
typedef struct plug_response
{
    size_t content_length;                       /*!< to be used as content length. if zero it might be calculated */
    const char *content_type;                   /*!< the content type for the response */
    const char *etag;                           /*!< content hash / etag */
    const char *location;                       /*!< uri for any location headers  */
    char buffer[CIT_HTTPD_SCRATCH_BUFFER_SIZE]; /*!< scratch buffer, usable storage for  etag/content_type */
} plug_response_t;

/**
 * @brief request information
 */
typedef struct plug_request
{
    void *session;                             /*!< session pointer, free to use by the application */
    enum http_method method;                   /*!< the http method of the request */
    size_t content_length;                        /*!< the content_length of the request */
    hash_t content_type_hash;                  /*!< djb2 hash of the content type for fast comparison */
    char uri[CIT_HTTPD_MAX_URI_LEN];           /*!< request URI */
    char path[CIT_HTTPD_MAX_PATH_LEN];         /*!< pattern match path, copy of the path of the URI, can be rewritten */
    char fragment[CIT_HTTPD_MAX_FRAGMENT_LEN]; /*!< the #fragment  */
    char query_string[CIT_HTTPD_MAX_QUERY_STRING_LEN]; /*!< query string parts of the url */
    char etag[CIT_HTTPD_SCRATCH_BUFFER_SIZE];          /*!< request etag, if provided */
    const char *path_match_end; /*!< end of pattern match in the path field, if a rule only matches a part */
    /* connection info */
    ip_addr_t *remote_ip; /*!< client ip */
    ip_addr_t *local_ip;  /*!< local server ip */
    u16_t remote_port;    /*!< client remote port */
    u16_t local_port;     /*!< local server port */

    u16_t accept_html : 1;     /*!< html is accepted by the client */
    u16_t accept_json : 1;     /*!< json is accepted by the client */
    u16_t accept_deflate : 1;  /*!< the client can use deflate decompression */
    u16_t keep_alive : 1;      /*!< the client supports keep_alive */
    u16_t expect : 1;          /*!< Expect etag query  */
    u16_t expect_continue : 1; /*!< Expect: 100-Continue */
    u16_t if_match : 1;        /*!< this is an if-match query */
    u16_t if_none_match : 1;   /*!< this is an if-none-match query */
    u16_t options : 1;         /*!< // this is an OPTIONS query */

} plug_request_t;

/* generate all callback types based on the list above */
_PLUG_EXTENSION_CALLBACK_TYPES()

/**
 * @brief the plug_extenson struct contains addresses of the plugins callback functions.
 *
 * if a function is not defined, the entry is NULL
 * member fields are defined in the table like macro in plug.h
 *
 */
struct plug_extension
{
    _PLUG_EXTENSION_STRUCT_MEMBERS()
};

/**
 * @brief temporary buffer shared between plug extensions
 */
extern char PLUG_TMP_BUFFER_SECTION plug_temp_buffer[TCP_SND_BUF];
#endif
